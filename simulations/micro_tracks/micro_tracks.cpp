// C++ dependencies
#include <iostream>

// ROOT dependencies
#include <TApplication.h>
#include <TFile.h>
#include <TTree.h>
#include <TRandom3.h>

// Dictionaries generated by ROOT
#include "../build/X17_dict.cxx"

// Garfield++ dependencies
#include "Garfield/AvalancheMC.hh"
#include "Garfield/AvalancheMicroscopic.hh"
#include "Garfield/ComponentAnalyticField.hh"
#include "Garfield/ComponentGrid.hh"
#include "Garfield/DriftLineRKF.hh"
#include "Garfield/MediumMagboltz.hh"
#include "Garfield/Plotting.hh"
#include "Garfield/Sensor.hh"
#include "Garfield/TrackHeed.hh"
#include "Garfield/ViewDrift.hh"
#include "Garfield/ViewField.hh"
#include "Garfield/ViewSignal.hh"

// X17 dependencies
#include "Points.h"
#include "Track.h"
#include "Utilities.h"
#include "X17Utilities.h"

using namespace Garfield;
using namespace X17::constants;

// Input parameter: number of tracks to be simulated.
int main(int argc, char *argv[])
{
    // Set parameters.
    int nTracks = 1;
    if (argc < 2) nTracks = std::stoi(argv[1]);

    TApplication app("app", &argc, argv);

    // Set the output file.
    std::string outPath = GetNextFilePath("","tracks(\\d+)\\.root"); //../../../data/micro_tracks/new_tracks/
    std::cout << "Output will be saved to: " + outPath + "\n";

    TFile outFile(outPath.c_str(),"RECREATE","Tracks from microscopic simulation");
    TTree tracks("tracks","Tree of simulated microscopic tracks");

    X17::TrackMicro microtrack;
    tracks.Branch("track",&microtrack);

    // Set the gas mixture.
    MediumMagboltz gas;
    gas.SetComposition("ar", 70., "co2", 30.);

    // Add magnetic and electric field.
    ComponentGrid grid;
    const double m2cm = 100.;
    grid.LoadMagneticField("../../../data/elmag/VecB2.txt", "xyz", m2cm); 
    grid.LoadElectricField("../../../data/elmag/VecE2.txt", "xyz", false, false, m2cm);
    grid.SetMedium(&gas);

    // Assemble a sensor.
    Sensor sensor;
    sensor.AddComponent(&grid);
    constexpr double space = 1; // Extra space on the sensor so electrons always end on zmax.
    sensor.SetArea(-space, xmin-space, zmin-space, xmax+space, space, zmax);

    // We use microscopic tracking for the electron avalanche simulation.
    AvalancheMicroscopic aval;
    aval.SetSensor(&sensor);
    aval.EnableSignalCalculation(); 
    aval.EnableMagneticField();

    // Random number generator for the simulation.
    TRandom3* rand = new TRandom3(0);

    // Loop over the tracks.
    for (int i = 0; i < nTracks; i++)
    {
        std::vector<X17::MicroPoint> points;

        // Generate random initial parameters of the track.
        bool electron;
        X17::Vector origin,orientation;
        double kin_en;

        X17::GetRandomTrackParams(rand,electron,origin,orientation,kin_en);

        // Simulate an ionizing particle using Heed.
        TrackHeed track;
        if (electron) track.SetParticle("electron");
        else          track.SetParticle("positron");

        track.SetKineticEnergy(kin_en); // Set the particle kinetic energy [eV].
        track.SetSensor(&sensor);
        track.EnableMagneticField();
        track.EnableElectricField();
        track.DisableDeltaElectronTransport();  // This will disable secondary electrons in the track.
        track.EnablePhotonReabsorption(false);  // Enable/disable fluorescence reabsorption.
        
        // Get the default parameters.
        double maxrange = 0., rforstraight = 0., stepstraight = 0., stepcurved = 0.;
        track.GetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Reduce the step size [rad].
        stepcurved = 0.04;
        maxrange = 0.2;
        track.SetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Set the starting point and momentum vector of the particle.
        double xt = origin.x;      // [cm]
        double yt = origin.y;      // [cm]
        double zt = origin.z;      // [cm]
        double ti = 0;             // [ns]
        double px = orientation.x;
        double py = orientation.y;
        double pz = orientation.z;

        // Simulate the track.
        track.NewTrack(xt, yt, zt, ti, px, py, pz);

        // Loop over the clusters.
        double xc, yc, zc, tc, ec, extra;
        int nc;
        while (track.GetCluster(xc, yc, zc, tc, nc, ec, extra)) 
        {
            for (int j = 0; j < nc; ++j) 
            {
                X17::MicroPoint point;
                double xe, ye, ze, te, ee, dxe, dye, dze;
                track.GetElectron(j, xe, ye, ze, te, ee, dxe, dye, dze);

                // Simulate the drift/avalanche of this electron.
                aval.AvalancheElectron(xe, ye, ze, te, 0.1, dxe, dye, dze);

                // Move electrons that hit the mesh plane into the amplification gap.
                int status;
                aval.GetElectronEndpoint(0, point.start.point.x, point.start.point.y, point.start.point.z, point.start.t, point.e0, point.end.point.x, point.end.point.y, point.end.point.z, point.end.t, point.e1, status);
                
                points.push_back(point);
            }
        }

        microtrack = X17::TrackMicro(electron,points,origin,orientation,kin_en);
        tracks.Fill();
    }

    outFile.Write();
    outFile.Close();

    app.Run(true);

    return 0;
}