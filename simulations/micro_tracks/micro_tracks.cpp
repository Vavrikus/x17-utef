// C++ dependencies
#include <filesystem>
#include <iostream>

// ROOT dependencies
#include <TApplication.h>
#include <TFile.h>
#include <TTree.h>
#include <TRandom3.h>

// Dictionaries generated by ROOT
#include "../build/X17_dict.cxx"

// Garfield++ dependencies
#include "Garfield/AvalancheMC.hh"
#include "Garfield/AvalancheMicroscopic.hh"
#include "Garfield/ComponentAnalyticField.hh"
#include "Garfield/ComponentGrid.hh"
#include "Garfield/DriftLineRKF.hh"
#include "Garfield/MediumMagboltz.hh"
#include "Garfield/Plotting.hh"
#include "Garfield/Sensor.hh"
#include "Garfield/TrackHeed.hh"
#include "Garfield/ViewDrift.hh"
#include "Garfield/ViewField.hh"
#include "Garfield/ViewSignal.hh"

// X17 dependencies
#include "Points.h"
#include "Track.h"
#include "TrackJob.h"
#include "Utilities.h"
#include "X17Utilities.h"

using namespace Garfield;
using namespace X17::constants;

// Input parameter: number of tracks to be simulated.
int main(int argc, char *argv[])
{
    // Set parameters.
    X17::TrackJob job;
    job.SetParameters(argc,argv);

    // Set the output file.
    std::string folder_path = std::filesystem::current_path().string(); // Get the current working directory.
    std::string outPath = GetNextFilePath(folder_path,"tracks"); //../../../data/micro_tracks/new_tracks/
    std::cout << "Output will be saved to: " + outPath + "\n";

    TFile outFile(outPath.c_str(),"RECREATE","Tracks from microscopic simulation");
    TTree tracks("tracks","Tree of simulated microscopic tracks");

    X17::TrackMicro microtrack;
    tracks.Branch("track",&microtrack);

    // Set the gas mixture.
    MediumMagboltz gas;
    gas.SetComposition("ar", 70., "co2", 30.);

    // Add magnetic and electric field.
    ComponentGrid grid;
    const double m2cm = 100.;
    grid.LoadMagneticField("../../../data/elmag/VecB2.txt", "xyz", m2cm); 
    grid.LoadElectricField("../../../data/elmag/VecE2.txt", "xyz", false, false, m2cm);
    grid.SetMedium(&gas);

    // Assemble a sensor.
    Sensor sensor;
    sensor.AddComponent(&grid);
    constexpr double space = 1; // Extra space on the sensor so electrons always end on zmax.
    sensor.SetArea(xmin-space, -yhigh-space, zmin-space, xmax+space, yhigh+space, zmax);

    // We use microscopic tracking for the electron avalanche simulation.
    AvalancheMicroscopic aval;
    aval.SetSensor(&sensor);
    aval.EnableSignalCalculation(); 
    aval.EnableMagneticField();
    aval.EnableDriftLines();

    // Random number generator for the simulation.
    TRandom3* rand = new TRandom3(0);

    // Loop over the tracks.
    for (int i = job.min_set; i <= job.max_set; i++)
    {
        std::vector<X17::MicroPoint> points;
        std::vector<std::vector<X17::DriftLinePoint>> driftlines;

        // Generate random initial parameters of the track.
        bool electron;
        X17::Vector origin,orientation;
        double kin_en;

        // Get initial track parameters (random or grid-like).
        if (job.random) X17::GetRandomTrackParams(rand,electron,origin,orientation,kin_en);
        else job.GetTrackParameters(i,electron,origin,orientation,kin_en);

        // Simulate an ionizing particle using Heed.
        TrackHeed track;
        if (electron) track.SetParticle("electron");
        else          track.SetParticle("positron");

        track.SetKineticEnergy(kin_en); // Set the particle kinetic energy [eV].
        track.SetSensor(&sensor);
        track.EnableMagneticField();
        track.EnableElectricField();
        track.DisableDeltaElectronTransport();  // This will disable secondary electrons in the track.
        track.EnablePhotonReabsorption(false);  // Enable/disable fluorescence reabsorption.
        
        // Get the default parameters.
        double maxrange = 0., rforstraight = 0., stepstraight = 0., stepcurved = 0.;
        track.GetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Reduce the step size [rad].
        stepcurved = 0.04;
        maxrange = 0.2;
        track.SetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Set the starting point and momentum vector of the particle.
        double xt = origin.x;      // [cm]
        double yt = origin.y;      // [cm]
        double zt = origin.z;      // [cm]
        double ti = 0;             // [ns]
        double px = orientation.x;
        double py = orientation.y;
        double pz = orientation.z;

        // Simulate the track.
        track.NewTrack(xt, yt, zt, ti, px, py, pz);

        // Loop over the clusters.
        double xc, yc, zc, tc, ec, extra;
        int nc;
        int n_electron = 0;
        while (track.GetCluster(xc, yc, zc, tc, nc, ec, extra)) 
        {
            for (int j = 0; j < nc; ++j) 
            {
                X17::MicroPoint point;
                double xe, ye, ze, te, ee, dxe, dye, dze;
                track.GetElectron(j, xe, ye, ze, te, ee, dxe, dye, dze);

                n_electron++;
                std::cout << "Distance to origin: " << sqrt(xe*xe+ye*ye+ze*ze) << "  time " << te << "  number " << n_electron << "\n";

                // Simulate the drift/avalanche of this electron.
                aval.AvalancheElectron(xe, ye, ze, te, ee, dxe, dye, dze);

                // Move electrons that hit the mesh plane into the amplification gap.
                int status;
                aval.GetElectronEndpoint(0, point.start.point.x, point.start.point.y, point.start.point.z, point.start.t, point.e0, point.end.point.x, point.end.point.y, point.end.point.z, point.end.t, point.e1, status);
                points.push_back(point);

                // Save driftlines.
                std::vector<X17::DriftLinePoint> driftline;

                for (int k = 0; k < aval.GetNumberOfElectronDriftLinePoints(); k++)
                {
                    X17::DriftLinePoint point;
                    aval.GetElectronDriftLinePoint(point.point.x,point.point.y,point.point.z,point.t,k);
                    driftline.push_back(point);
                }

                driftlines.push_back(driftline);
            }
        }

        microtrack = X17::TrackMicro(electron,points,origin,orientation,kin_en,driftlines);
        tracks.Fill();
    }

    outFile.Write();
    outFile.Close();

    return 0;
}