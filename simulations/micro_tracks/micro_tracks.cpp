// C++ dependencies
#include <filesystem>
#include <iostream>

// ROOT dependencies
#include <TApplication.h>
#include <TFile.h>
#include <TTree.h>
#include <TRandom3.h>

// Dictionaries generated by ROOT
#include "../build/X17_dict.cxx"

// Garfield++ dependencies
#include "Garfield/AvalancheMC.hh"
#include "Garfield/AvalancheMicroscopic.hh"
#include "Garfield/ComponentAnalyticField.hh"
#include "Garfield/ComponentGrid.hh"
#include "Garfield/DriftLineRKF.hh"
#include "Garfield/MediumMagboltz.hh"
#include "Garfield/Plotting.hh"
#include "Garfield/Sensor.hh"
#include "Garfield/TrackHeed.hh"
#include "Garfield/ViewDrift.hh"
#include "Garfield/ViewField.hh"
#include "Garfield/ViewSignal.hh"

// X17 dependencies
#include "Points.h"
#include "Track.h"
#include "TrackJob.h"
#include "Utilities.h"
#include "X17Utilities.h"

using namespace Garfield;
using namespace X17::constants;

// Input parameters: max_id, id, iterations, angle_bins, energy_bins (for grid-like simulation).
// For random simulation of one track run with no parameters.
int main(int argc, char *argv[])
{
    // Set parameters.
    X17::TrackJob job;
    job.SetParameters(argc,argv);

    // Set the output files.
    std::string folder_path = std::filesystem::current_path().string(); // Get the current working directory.
    std::string outPath  = GetNextFilePath(folder_path,"tracks_full");  // Big file containing the drift lines.
    std::string outPath2 = GetNextFilePath(folder_path,"tracks_small"); // Small file without the drift lines.
    std::cout << "Full output will be saved to: " + outPath + "\n";
    std::cout << "Small output will be saved to: " + outPath2 + "\n";

    TFile outFile(outPath.c_str(),"RECREATE","Tracks from microscopic simulation (with drift lines)");

    TTree tracks("tracks_full","Tree of simulated microscopic tracks (with drift lines)");
    TTree tracks2("tracks_small","Tree of simulated microscopic tracks (no drift lines)");

    X17::TrackMicro microtrack;
    X17::TrackMicro microtrack2;
    tracks.Branch("track_full",&microtrack);
    tracks2.Branch("track_small",&microtrack2);

    // Set the gas mixture.
    MediumMagboltz gas;
    gas.SetComposition("ar", 70., "co2", 30.);

    // Add magnetic and electric field.
    ComponentGrid grid;
    const double m2cm = 100.;
    grid.LoadMagneticField("../../../data/elmag/VecB2.txt", "xyz", m2cm); 
    grid.LoadElectricField("../../../data/elmag/VecE2.txt", "xyz", false, false, m2cm);
    grid.SetMedium(&gas);

    // Assemble a sensor.
    Sensor sensor;
    sensor.AddComponent(&grid);
    constexpr double space = 1; // Extra space on the sensor so electrons always end on zmax.
    sensor.SetArea(xmin-space, -yhigh-space, zmin-space, xmax+space, yhigh+space, zmax);

    // We use microscopic tracking for the electron avalanche simulation.
    AvalancheMicroscopic aval;
    aval.SetSensor(&sensor);
    aval.EnableSignalCalculation(); 
    aval.EnableMagneticField();
    aval.EnableDriftLines();

    // Random number generator for the simulation.
    TRandom3* rand = new TRandom3(0);

    // Loop over the tracks.
    for (int i = job.min_set; i <= job.max_set; i++)
    {
        std::vector<X17::MicroPoint> points;
        std::vector<std::vector<X17::DriftLinePoint>> driftlines;

        // Generate random initial parameters of the track.
        bool electron;
        X17::Vector origin,orientation;
        double kin_en;

        // Get initial track parameters (random or grid-like).
        if (job.random) X17::GetRandomTrackParams(rand,electron,origin,orientation,kin_en);
        else job.GetTrackParameters(i,electron,origin,orientation,kin_en);
        
        std::cout << "TRACK No." << i << ":\n";
        std::cout << "   electron: " << electron << " Ek: " << kin_en << " origin: (" << origin.x << "," << origin.y << "," << origin.z << ")\n";
        std::cout << "   orientation: (" << orientation.x << "," << orientation.y << "," << orientation.z << ")\n";
        std::cout << "   theta: " << asin(orientation.z) << " phi: " << acos(orientation.x/cos(asin(orientation.z)))*sign(orientation.y) << "\n";

        // Simulate an ionizing particle using Heed.
        TrackHeed track;
        if (electron) track.SetParticle("electron");
        else          track.SetParticle("positron");

        track.SetKineticEnergy(kin_en); // Set the particle kinetic energy [eV].
        track.SetSensor(&sensor);
        track.EnableMagneticField();
        track.EnableElectricField();
        track.DisableDeltaElectronTransport();  // This will disable secondary electrons in the track.
        track.EnablePhotonReabsorption(false);  // Enable/disable fluorescence reabsorption.
        
        // Get the default parameters.
        double maxrange = 0., rforstraight = 0., stepstraight = 0., stepcurved = 0.;
        track.GetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Reduce the step size [rad].
        stepcurved = 0.04;
        maxrange = 0.2;
        track.SetSteppingLimits(maxrange, rforstraight, stepstraight, stepcurved);

        // Set the starting point and momentum vector of the particle.
        double xt = origin.x;      // [cm]
        double yt = origin.y;      // [cm]
        double zt = origin.z;      // [cm]
        double ti = 0;             // [ns]
        double px = orientation.x;
        double py = orientation.y;
        double pz = orientation.z;

        // Simulate the track.
        track.NewTrack(xt, yt, zt, ti, px, py, pz);

        // Loop over the clusters.
        double xc, yc, zc, tc, ec, extra;
        int nc;
        int n_electron = 0;
        while (track.GetCluster(xc, yc, zc, tc, nc, ec, extra)) 
        {
            for (int j = 0; j < nc; ++j) 
            {
                X17::MicroPoint point;
                double xe, ye, ze, te, ee, dxe, dye, dze;
                track.GetElectron(j, xe, ye, ze, te, ee, dxe, dye, dze);

                n_electron++;
                std::cout << "Distance to origin: " << sqrt(xe*xe+ye*ye+ze*ze) << "  time " << te << "  number " << n_electron << std::endl;

                // Simulate the drift/avalanche of this electron.
                aval.AvalancheElectron(xe, ye, ze, te, ee, dxe, dye, dze);

                // Move electrons that hit the mesh plane into the amplification gap.
                int status;
                aval.GetElectronEndpoint(0, point.start.point.x, point.start.point.y, point.start.point.z, point.start.t, point.e0, point.end.point.x, point.end.point.y, point.end.point.z, point.end.t, point.e1, status);
                points.push_back(point);

                // Save driftlines.
                std::vector<X17::DriftLinePoint> driftline;

                for (int k = 0; k < aval.GetNumberOfElectronDriftLinePoints(); k++)
                {
                    X17::DriftLinePoint dl_point;
                    aval.GetElectronDriftLinePoint(dl_point.point.x,dl_point.point.y,dl_point.point.z,dl_point.t,k);
                    driftline.push_back(dl_point);
                }

                driftlines.push_back(driftline);
            }

            // break; // Only for fast testing (simulates only one electron)!!!
        }

        microtrack = X17::TrackMicro(electron,points,origin,orientation,kin_en,driftlines);
        microtrack2 = X17::TrackMicro(electron,points,origin,orientation,kin_en,{});
        
        tracks.Fill();
        tracks2.Fill();
    }

    // Write the file with complete data.
    outFile.cd();
    tracks.Write();
    outFile.Close();

    // Write the file with no drift lines.
    TFile outFile2(outPath2.c_str(),"RECREATE","Tracks from microscopic simulation (no drift lines)");

    outFile2.cd();
    tracks2.Write();
    outFile2.Close();    

    return 0;
}