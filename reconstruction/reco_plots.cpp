// C++ dependencies
#include <cmath>
#include <iostream>
#include <string>

// ROOT dependencies
#include "TCanvas.h"
#include "TF1.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3F.h"
#include "TLatex.h"
#include "TMath.h"
#include "TPaletteAxis.h"
#include "TStyle.h"
#include "TTree.h"

// Dictionaries generated by ROOT
#include "../build/X17_dict.cxx"

// X17 dependencies
#include "LinearFit.h"
#include "Track.h"
#include "Utilities.h"
#include "X17Utilities.h"

constexpr int fit_param = 4;

double Get_a0(bool electron, int p = 4, bool use_reco = false)
{
    if (use_reco && p == 4) return electron ? -0.143346 : -0.167961;
    
    return 0;
}
double Get_a1(bool electron, int p = 4, bool use_reco = false)
{
    if (use_reco && p == 4) return electron ? -0.0841256 : 0.0922397;
    
    return 0;
}
double Get_a2(bool electron, int p = 4, bool use_reco = false)
{
    if (use_reco && p == 4) return electron ? 0.0208461 : -0.0331023;
    
    return 0;
}
double Get_a3(bool electron, int p = 4, bool use_reco = false)
{
    if (use_reco && p == 4) return electron ? -0.00137187 : 0.000224353;
    
    return 0;
}

// double RecoCorr(bool electron, double e_sim, double e_rec, double theta, double varphi)
// {
//     return e_rec 
// }

double FitCorrection(bool electron, double e_sim, double e_rec, double theta, double varphi, int p = 4, bool use_reco = false)
{
    // return 0;
    if (use_reco)
    {
        if (p == 4)
        {
            return electron ? -0.143346 - 0.0841256*e_rec + 0.0208461*theta - 0.00137187*varphi   // fit [-4,2]
                            : -0.167961 + 0.0922397*e_rec - 0.0331023*theta + 0.000224353*varphi; // fit [-2,4]
        }         
    }

    else
    {
        if (p == 4)
        {
            // return electron ? 0.705521 - 0.179129*e_sim  + 0.0195747*theta - 0.010889*varphi
            //                 : 0.487641 + 0.0382395*e_sim - 0.0373979*theta - 0.00469622*varphi;
            return electron ? -0.104444 - 0.088225*e_sim  + 0.0206748*theta - 0.00136367*varphi  // fit [-4,2]
                            : -0.128394 + 0.0879214*e_sim - 0.0333912*theta - 0.00223458*varphi; // fit [-2,4]
        }

        if (p == 2)
        {
            return electron ? 0.705647 - 0.179144*e_sim : 0.486942 + 0.0382954*e_sim;
        }
    }

    return 0;
}

int main(int argc, char const *argv[])
{
    using namespace X17::constants;
    std::string data_folder = "../../data/micro_tracks/";

    // Loading file with track information.
    TFile* input = new TFile((data_folder + "reco_tracks.root").c_str());
    TTree* tracks_info = (TTree*)input->Get("tracks_info");

    X17::TrackInfo* curr_info = nullptr;
    tracks_info->SetBranchAddress("track_info",&curr_info);

    // Output file.
    TFile out_file((data_folder + "tracks_fit.root").c_str(),"RECREATE","Microscopic tracks reconstruction plots");                                                                             // THe minimal simulated energy [MeV].

    // Reconstruction ranges.
    double res_min = -10;
    double res_max = -res_min;
    // double res_bins = 81;
    // double res_bins_small = 51;

    // Adjusting boundaries for the extra bin.
    double phi_max   = X_phi_min   + (X_phi_max - X_phi_min)     * X_angle_bins  / (X_angle_bins  - 1);
    double theta_max = X_theta_min + (X_theta_max - X_theta_min) * X_angle_bins  / (X_angle_bins  - 1);
    double E_max     = X_E_min     + (X_E_max   - X_E_min)       * X_energy_bins / (X_energy_bins - 1);
    double E_min     = X_E_min;
    int angle_bins  = X_angle_bins;
    int energy_bins = X_energy_bins;

    // Shifting angle bin boundaries by half a bin in order to avoid rounding error problems.
    double phi_shift   = (phi_max   - X_phi_min)   / (2 * X_angle_bins);
    double theta_shift = (theta_max - X_theta_min) / (2 * X_angle_bins);
    double phi_min   = X_phi_min   - phi_shift;
    double theta_min = X_theta_min - theta_shift;
    phi_max   -= phi_shift;
    theta_max -= theta_shift;

    // Histogram titles.
    const char* h_all_title                 = ";Phi [deg];Theta [deg];Simulated energy [MeV]";
    const char* h_theta_phi_title           = ";Phi [deg];Theta [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_theta_energy_title        = ";Theta [deg];Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_phi_energy_title          = ";Phi [deg];Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_energy_title  = ";Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_energy_title2 = ";Reconstructed energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_phi_title     = ";#varphi [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_theta_title   = ";#theta [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_delta_energy_title        = ";#frac{E_{rec}-E}{E} [\%];# of events";

    // Histogram initializations.
    TH3F* he_all                = new TH3F("he_all",h_all_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_theta_phi          = new TH2F("he_theta_phi",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* he_theta_energy       = new TH2F("he_theta_energy",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_phi_energy         = new TH2F("he_phi_energy",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* he_theta_phi_abs      = new TH2F("he_theta_phi_abs",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* he_theta_energy_abs   = new TH2F("he_theta_energy_abs",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_phi_energy_abs     = new TH2F("he_phi_energy_abs",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    
    TH3F* hp_all                = new TH3F("hp_all",h_all_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_theta_phi          = new TH2F("hp_theta_phi",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* hp_theta_energy       = new TH2F("hp_theta_energy",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_phi_energy         = new TH2F("hp_phi_energy",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* hp_theta_phi_abs      = new TH2F("hp_theta_phi_abs",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* hp_theta_energy_abs   = new TH2F("hp_theta_energy_abs",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_phi_energy_abs     = new TH2F("hp_phi_energy_abs",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    
    // For res_bin calculation
    std::vector<double> ve_res_vec;
    std::vector<double> vp_res_vec;
    
    // Struct for 2D histogram data computation.
    struct AverageCounter
    {
        double value = 0; // Here sum will be computed.
        int numbers  = 0; // How many times was a number added.
        
        void Add(double x) { value += x; numbers++; }
        double Average() { return (numbers == 0) ? 0 : value/numbers; }
    };
    
    
    // Arrays for 2D histograms.
    AverageCounter e_all[angle_bins][angle_bins][energy_bins];
    AverageCounter e_theta_phi[angle_bins][angle_bins];
    AverageCounter e_theta_energy[angle_bins][energy_bins];
    AverageCounter e_phi_energy[angle_bins][energy_bins];
    AverageCounter e_theta_phi_abs[angle_bins][angle_bins];
    AverageCounter e_theta_energy_abs[angle_bins][energy_bins];
    AverageCounter e_phi_energy_abs[angle_bins][energy_bins];
    
    AverageCounter p_all[angle_bins][angle_bins][energy_bins];
    AverageCounter p_theta_phi[angle_bins][angle_bins];
    AverageCounter p_theta_energy[angle_bins][energy_bins];
    AverageCounter p_phi_energy[angle_bins][energy_bins];
    AverageCounter p_theta_phi_abs[angle_bins][angle_bins];
    AverageCounter p_theta_energy_abs[angle_bins][energy_bins];
    AverageCounter p_phi_energy_abs[angle_bins][energy_bins];

    std::vector<FPoint> data;
    
    for (int i = 0; i < tracks_info->GetEntries(); i++)
    {
        tracks_info->GetEntry(i);

        bool electron = curr_info->electron;
        double e_sim = curr_info->kin_energy;
        double theta = curr_info->theta;
        double phi   = curr_info->phi;
        double rk_resolution = curr_info->GetRKRelError();
        double e_rec = curr_info->rkfit_energy;
        
        // if (electron) continue;
        rk_resolution -= FitCorrection(electron, e_sim, e_rec, theta, phi, fit_param, true);
        e_rec = e_sim*(rk_resolution/100) + e_sim;
        // std::cout << "e_sim: " << e_sim << " theta: " << theta << " phi: " << phi << " rk_resolution: " << rk_resolution << " fit_mean: " << fit_mean << std::endl;
        
        if ((rk_resolution < -2) || (rk_resolution > 4))
        {
            // std::cout << "Error: " << std::abs(rk_resolution) << std::endl; continue;
        }
        data.push_back({electron,e_sim,e_rec,theta,phi,rk_resolution});
        
        int phi_bin    = floor(angle_bins * (curr_info->phi - phi_min) / (phi_max - phi_min));
        int theta_bin  = floor(angle_bins * (curr_info->theta - theta_min) / (theta_max - theta_min));
        int energy_bin = floor(energy_bins * (curr_info->kin_energy - E_min) / (E_max - E_min));
        
        if (energy_bin == energy_bins) energy_bin--;
        
        if (curr_info->electron)
        {
            ve_res_vec.push_back(rk_resolution);
            
            e_all[phi_bin][theta_bin][energy_bin].Add(rk_resolution);
            e_theta_phi[phi_bin][theta_bin].Add(rk_resolution);
            e_theta_energy[theta_bin][energy_bin].Add(rk_resolution);
            e_phi_energy[phi_bin][energy_bin].Add(rk_resolution);
            e_theta_phi_abs[phi_bin][theta_bin].Add(std::abs(rk_resolution));
            e_theta_energy_abs[theta_bin][energy_bin].Add(std::abs(rk_resolution));
            e_phi_energy_abs[phi_bin][energy_bin].Add(std::abs(rk_resolution));
        }
        
        else
        {
            vp_res_vec.push_back(rk_resolution);
            
            p_all[phi_bin][theta_bin][energy_bin].Add(rk_resolution);
            p_theta_phi[phi_bin][theta_bin].Add(rk_resolution);
            p_theta_energy[theta_bin][energy_bin].Add(rk_resolution);
            p_phi_energy[phi_bin][energy_bin].Add(rk_resolution);
            p_theta_phi_abs[phi_bin][theta_bin].Add(std::abs(rk_resolution));
            p_theta_energy_abs[theta_bin][energy_bin].Add(std::abs(rk_resolution));
            p_phi_energy_abs[phi_bin][energy_bin].Add(std::abs(rk_resolution));
        }
    }

    // Fill 3D histograms from arrays.
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < angle_bins; j++) for (int k = 0; k < energy_bins; k++)
    {
        double phi   = phi_min + (phi_max - phi_min) * (i + 0.5) / angle_bins;
        double theta = theta_min + (theta_max - theta_min) * (j + 0.5) / angle_bins;
        double energy = E_min + (E_max - E_min) * k / energy_bins;
        
        he_all->Fill(phi,theta,energy,e_all[i][j][k].Average());
        hp_all->Fill(phi,theta,energy,p_all[i][j][k].Average());
    }

    // Fill 2D histograms from arrays.
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < angle_bins; j++)
    {
        double phi = phi_min + (phi_max - phi_min) * (i + 0.5) / angle_bins;
        double theta = theta_min + (theta_max - theta_min) * (j + 0.5) / angle_bins;
        
        he_theta_phi->Fill(phi,theta,e_theta_phi[i][j].Average());
        he_theta_phi_abs->Fill(phi,theta,e_theta_phi_abs[i][j].Average());
        hp_theta_phi->Fill(phi,theta,p_theta_phi[i][j].Average());
        hp_theta_phi_abs->Fill(phi,theta,p_theta_phi_abs[i][j].Average());
    }
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < energy_bins; j++)
    {
        double phi   = phi_min + (phi_max - phi_min) * (i + 0.5) / angle_bins;
        double theta = theta_min + (theta_max - theta_min) * (i + 0.5) / angle_bins;
        double e_kin = E_min + (E_max - E_min) * j / energy_bins;

        he_theta_energy->Fill(theta,e_kin,e_theta_energy[i][j].Average());
        he_phi_energy->Fill(phi,e_kin,e_phi_energy[i][j].Average());
        hp_theta_energy->Fill(theta,e_kin,p_theta_energy[i][j].Average());
        hp_phi_energy->Fill(phi,e_kin,p_phi_energy[i][j].Average());
        he_theta_energy_abs->Fill(theta,e_kin,e_theta_energy_abs[i][j].Average());
        he_phi_energy_abs->Fill(phi,e_kin,e_phi_energy_abs[i][j].Average());
        hp_theta_energy_abs->Fill(theta,e_kin,p_theta_energy_abs[i][j].Average());
        hp_phi_energy_abs->Fill(phi,e_kin,p_phi_energy_abs[i][j].Average());
    }
    
    // Calculate res_bins
    int e_res_bins = GetBinsFreedmanDiaconis(ve_res_vec,res_min,res_max);
    int p_res_bins = GetBinsFreedmanDiaconis(vp_res_vec,res_min,res_max);
    int e_res_bins_energy = e_res_bins / std::pow(energy_bins,1./3.);
    int p_res_bins_energy = p_res_bins / std::pow(energy_bins,1./3.);
    int e_res_bins_angle = e_res_bins / std::pow(angle_bins,1./3.);
    int p_res_bins_angle = p_res_bins / std::pow(angle_bins,1./3.);
    
    // Remaining histograms
    TH2F* he_deltaenergy_energy  = new TH2F("he_deltaenergy_energy",h_deltaenergy_energy_title,energy_bins,E_min,E_max,e_res_bins_energy,res_min,res_max);
    TH2F* he_deltaenergy_energy2 = new TH2F("he_deltaenergy_energy2",h_deltaenergy_energy_title2,energy_bins+1,E_min-1,E_max,e_res_bins_energy,res_min,res_max);
    TH2F* he_deltaenergy_phi     = new TH2F("he_deltaenergy_phi",h_deltaenergy_phi_title,angle_bins,phi_min,phi_max,e_res_bins_angle,res_min,res_max);
    TH2F* he_deltaenergy_theta   = new TH2F("he_deltaenergy_theta",h_deltaenergy_theta_title,angle_bins,theta_min,theta_max,e_res_bins_angle,res_min,res_max);
    TH1F* he_delta_energy        = new TH1F("he_delta_energy",h_delta_energy_title,e_res_bins,res_min,res_max);

    TH2F* hp_deltaenergy_energy  = new TH2F("hp_deltaenergy_energy",h_deltaenergy_energy_title,energy_bins,E_min,E_max,p_res_bins_energy,res_min,res_max);
    TH2F* hp_deltaenergy_energy2 = new TH2F("hp_deltaenergy_energy2",h_deltaenergy_energy_title2,energy_bins+1,E_min-1,E_max,p_res_bins_energy,res_min,res_max);
    TH2F* hp_deltaenergy_phi     = new TH2F("hp_deltaenergy_phi",h_deltaenergy_phi_title,angle_bins,phi_min,phi_max,p_res_bins_angle,res_min,res_max);
    TH2F* hp_deltaenergy_theta   = new TH2F("hp_deltaenergy_theta",h_deltaenergy_theta_title,angle_bins,theta_min,theta_max,p_res_bins_angle,res_min,res_max);
    TH1F* hp_delta_energy        = new TH1F("hp_delta_energy",h_delta_energy_title,p_res_bins,res_min,res_max);

    for (TH2F* h : {he_deltaenergy_energy,he_deltaenergy_energy2,he_deltaenergy_phi,he_deltaenergy_theta,hp_deltaenergy_energy,hp_deltaenergy_energy2,hp_deltaenergy_phi,hp_deltaenergy_theta})
    {
        ApplyThesisStyle(h);
        h->GetXaxis()->SetTitleOffset(1);
        h->GetYaxis()->SetTitleOffset(0.9);
    }

    auto th2_c = [](TCanvas* c){
        c->SetTopMargin(0.05);
        double e_mar_l = 0.05;
        double e_mar_r = 0.035;
        double e_mar_b = 0.03;
        double wf = 0.9/(0.9-e_mar_l-e_mar_r);
        double hf = 0.9/(0.9-e_mar_b);
        c->SetLeftMargin(e_mar_l+0.1);
        c->SetRightMargin(e_mar_r+0.1);
        c->SetBottomMargin(e_mar_b+0.1);
        c->SetWindowSize(wf*700,hf*500);
    };

    for (TH1F* h : {he_delta_energy,hp_delta_energy})
    {
        ApplyThesisStyle(h);
        h->GetXaxis()->SetTitleOffset(1.3);
        h->GetYaxis()->SetTitleOffset(1.15);
    }

    auto th1_c = [](TCanvas* c){
        c->SetTopMargin(0.05);
        c->SetRightMargin(0.05);
        double e_mar_l = 0.03;
        double e_mar_b = 0.09;
        double wf = 0.9/(0.9-e_mar_l);
        double hf = 0.9/(0.9-e_mar_b);
        c->SetLeftMargin(e_mar_l+0.1);
        c->SetBottomMargin(e_mar_b+0.1);
        c->SetWindowSize(wf*700,hf*500);
    };
    
    for (FPoint p : data)
    {        
        if (p.electron)
        {
            he_deltaenergy_energy->Fill(p.e_sim,p.dev_reco);
            he_deltaenergy_energy2->Fill(p.e_rec,p.dev_reco);
            he_deltaenergy_phi->Fill(p.varphi,p.dev_reco);
            he_deltaenergy_theta->Fill(p.theta,p.dev_reco);
            he_delta_energy->Fill(p.dev_reco);
        }
        
        else
        {
            hp_deltaenergy_energy->Fill(p.e_sim,p.dev_reco);
            hp_deltaenergy_energy2->Fill(p.e_rec,p.dev_reco);
            hp_deltaenergy_phi->Fill(p.varphi,p.dev_reco);
            hp_deltaenergy_theta->Fill(p.theta,p.dev_reco);
            hp_delta_energy->Fill(p.dev_reco);
        }
    }

    // Set the contour levels symmetrically around zero
    int ncont = 256;  // Number of contour levels (adjust as needed)
    gStyle->SetNumberContours(ncont);
    Double_t contours[ncont + 1];
    for (int i = 0; i <= ncont; ++i) contours[i] = -10 + i * (20.0 / ncont);
    
    std::string c_names_all[2] = {"c_e_all","c_p_all"};
    TH3F* h_all[2] = {he_all,hp_all};

    for (int i = 0; i < 2; i++)
    {
        TCanvas* c = new TCanvas(c_names_all[i].c_str(),"");
        gStyle->SetPalette(kLightTemperature);
        h_all[i]->SetStats(0);
        h_all[i]->SetContour(ncont);
        h_all[i]->Draw("box2 z");
        c->Write();
    }

    std::string c_names_extras[12] = {"c_e_theta_phi","c_e_theta_energy","c_e_phi_energy",
                                      "c_p_theta_phi","c_p_theta_energy","c_p_phi_energy",
                                      "c_e_theta_phi_abs","c_e_theta_energy_abs","c_e_phi_energy_abs",
                                      "c_p_theta_phi_abs","c_p_theta_energy_abs","c_p_phi_energy_abs"};
    TH2F* h_extras[12] = {he_theta_phi,he_theta_energy,he_phi_energy,
                          hp_theta_phi,hp_theta_energy,hp_phi_energy,
                          he_theta_phi_abs,he_theta_energy_abs,he_phi_energy_abs,
                          hp_theta_phi_abs,hp_theta_energy_abs,hp_phi_energy_abs};

    for (int i = 0; i < 12; i++)
    {
        TCanvas* c = new TCanvas(c_names_extras[i].c_str(),"");
        gStyle->SetPalette(kLightTemperature);
        h_extras[i]->SetStats(0);
        h_extras[i]->SetContour(ncont);
        h_extras[i]->Draw("colz");
        c->Write();
    }


    std::string c_names_2d[8] = {"c_e_deltaenergy_energy","c_e_deltaenergy_energy2","c_e_deltaenergy_theta","c_e_deltaenergy_phi",
                                 "c_p_deltaenergy_energy","c_p_deltaenergy_energy2","c_p_deltaenergy_theta","c_p_deltaenergy_phi"};
    TH2F* histos_2d[8] = {he_deltaenergy_energy,he_deltaenergy_energy2,he_deltaenergy_theta,he_deltaenergy_phi,
                          hp_deltaenergy_energy,hp_deltaenergy_energy2,hp_deltaenergy_theta,hp_deltaenergy_phi};
    int maxima[8] = {300,250,160,180,300,250,160,180};

    for (int i = 0; i < 8; i++)
    {
        TCanvas* c = new TCanvas(c_names_2d[i].c_str(),"");
        th2_c(c);
        histos_2d[i]->SetStats(0);
        histos_2d[i]->SetContour(ncont);
        histos_2d[i]->SetMaximum(maxima[i]);
        histos_2d[i]->Draw("colz");
        TLine* y0_line = new TLine(histos_2d[i]->GetXaxis()->GetXmin(),0,histos_2d[i]->GetXaxis()->GetXmax(),0);
        y0_line->SetLineWidth(4);
        y0_line->Draw("same");
        c->Write();
    }


    std::string c_names[2] = {"c_e_delta_energy","c_p_delta_energy"};
    TH1F* h_deltas[2] = {he_delta_energy,hp_delta_energy};

    for (int i = 0; i < 2; i++)
    {
        TCanvas* c = new TCanvas(c_names[i].c_str(),"");
        th1_c(c);
        h_deltas[i]->SetStats(0);
        h_deltas[i]->Fit("gaus");
        h_deltas[i]->Draw();

        TF1* fit = h_deltas[i]->GetFunction("gaus");
        // TF1* fit = GetSkewGaus(-10,10);
        // fit->SetParameters(1,0,1,(i-1)*0.5);
        // fit->SetParLimits(2,0,20);
        fit->SetNpx(1000);
        // h_deltas[i]->Fit(fit,"M");
        double mean,stdev,skewness,fwhm;
        // GetSkewGausStats(fit,mean,stdev,skewness,fwhm);
        mean = fit->GetParameter(1);
        stdev = fit->GetParameter(2);
        skewness = 0;
        fwhm = 2.35482 * stdev;

        // double fwhm = GetFWHM(h_deltas[i],false);
        // double mean = h_deltas[i]->GetMean();
        // double stdev = h_deltas[i]->GetStdDev();
        // double skewness = h_deltas[i]->GetSkewness();
        // double kurtosis = h_deltas[i]->GetKurtosis();

        // Add text labels with information
        TLatex* label = new TLatex();
        label->SetNDC();
        label->SetTextSize(0.055);

        label->DrawLatex(0.68, 0.85, Form("Mean: %.2f%%", mean));
        label->DrawLatex(0.68, 0.78, Form("FWHM: %.2f%%", fwhm));
        label->DrawLatex(0.68, 0.71, Form("Sigma: %.2f%%", stdev));
        // label->DrawLatex(0.68, 0.64, Form("Skew: %.2f", skewness));
        // label->DrawLatex(0.75, 0.70, Form("Kurtosis: %.2f", kurtosis));
        c->Write();
    }

    LinearFit3D(data, fit_param, true);

    return 0;
}