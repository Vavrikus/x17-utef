// C++ dependencies
#include <cmath>
#include <iostream>
#include <string>

// ROOT dependencies
#include "TCanvas.h"
#include "TF1.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH2F.h"
#include "TH3F.h"
#include "TLatex.h"
#include "TMath.h"
#include "TPaletteAxis.h"
#include "TStyle.h"
#include "TTree.h"

// Dictionaries generated by ROOT
#include "../build/X17_dict.cxx"

// X17 dependencies
#include "Track.h"
#include "Utilities.h"
#include "X17Utilities.h"

int main(int argc, char const *argv[])
{
    std::string data_folder = "../../data/micro_tracks/grid_01/";

    // Loading file with track information.
    TFile* input = new TFile((data_folder + "reco_tracks.root").c_str());
    TTree* tracks_info = (TTree*)input->Get("tracks_info");

    X17::TrackInfo* curr_info = nullptr;
    tracks_info->SetBranchAddress("track_info",&curr_info);

    // Output file.
    TFile out_file((data_folder + "tracks_fit.root").c_str(),"RECREATE","Microscopic tracks reconstruction plots");

    // Binning.
    constexpr int angle_bins  = 21;
    constexpr int energy_bins = 11;

    // Ranges for simulation.
    double theta_max = (180/TMath::Pi())*atan((X17::constants::win_height/2)/X17::constants::xmin); // The maximal simulated theta [deg].
    double theta_min = -theta_max;                                                                  // The minimal simulated theta [deg].
    double phi_max = (180/TMath::Pi())*atan((X17::constants::win_width/2)/X17::constants::xmin);    // The maximal simulated phi [deg].
    double phi_min = -phi_max;                                                                      // The minimal simulated phi [deg].
    double E_max = 13;                                                                              // The maximal simulated energy [MeV].
    double E_min = 3;                                                                               // THe minimal simulated energy [MeV].

    // Reconstruction ranges.
    double res_min = -20;
    double res_max = -res_min;
    double res_bins = 81;
    double res_bins_small = 51;

    // Adjusting boundaries for the extra bin.
    phi_max   = phi_min   + (phi_max   - phi_min)   * angle_bins  / (angle_bins  - 1);
    theta_max = theta_min + (theta_max - theta_min) * angle_bins  / (angle_bins  - 1);
    E_max     = E_min     + (E_max     - E_min)     * energy_bins / (energy_bins - 1);

    // Shifting angle bin boundaries by half a bin in order to avoid rounding error problems.
    double phi_shift   = (phi_max - phi_min) / (2 * angle_bins);
    double theta_shift = (theta_max - theta_min) / (2 * angle_bins);
    phi_min   -= phi_shift;
    phi_max   -= phi_shift;
    theta_min -= theta_shift;
    theta_max -= theta_shift;

    // Histogram titles.
    const char* h_all_title                = "Energy resolution (#frac{E_{rec}-E}{E});Phi [deg];Theta [deg];Simulated energy [MeV]";
    const char* h_theta_phi_title          = "Energy resolution (#frac{E_{rec}-E}{E});Phi [deg];Theta [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_theta_energy_title       = "Energy resolution (#frac{E_{rec}-E}{E});Theta [deg];Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_phi_energy_title         = "Energy resolution (#frac{E_{rec}-E}{E});Phi [deg];Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_energy_title = "Energy resolution dependence on energy;Simulated energy [MeV];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_phi_title    = "Energy resolution dependence on phi;Phi [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_deltaenergy_theta_title  = "Energy resolution dependence on theta;Theta [deg];#frac{E_{rec}-E}{E} [\%]";
    const char* h_delta_energy_title       = "Energy resolution of Runge-Kutta reconstruction (with pads);#frac{E_{rec}-E}{E} [\%];# of events";

    // Histogram initializations.
    TH3F* he_all                = new TH3F("he_all",h_all_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_theta_phi          = new TH2F("he_theta_phi",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* he_theta_energy       = new TH2F("he_theta_energy",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_phi_energy         = new TH2F("he_phi_energy",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* he_theta_phi_abs      = new TH2F("he_theta_phi_abs",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* he_theta_energy_abs   = new TH2F("he_theta_energy_abs",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* he_phi_energy_abs     = new TH2F("he_phi_energy_abs",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* he_deltaenergy_energy = new TH2F("he_deltaenergy_energy",h_deltaenergy_energy_title,energy_bins,E_min,E_max,res_bins_small,res_min,res_max);
    TH2F* he_deltaenergy_phi    = new TH2F("he_deltaenergy_phi",h_deltaenergy_phi_title,angle_bins,phi_min,phi_max,res_bins_small,res_min,res_max);
    TH2F* he_deltaenergy_theta  = new TH2F("he_deltaenergy_theta",h_deltaenergy_theta_title,angle_bins,theta_min,theta_max,res_bins_small,res_min,res_max);
    TH1F* he_delta_energy       = new TH1F("he_delta_energy",h_delta_energy_title,res_bins,res_min,res_max);

    TH3F* hp_all                = new TH3F("hp_all",h_all_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_theta_phi          = new TH2F("hp_theta_phi",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* hp_theta_energy       = new TH2F("hp_theta_energy",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_phi_energy         = new TH2F("hp_phi_energy",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* hp_theta_phi_abs      = new TH2F("hp_theta_phi_abs",h_theta_phi_title,angle_bins,phi_min,phi_max,angle_bins,theta_min,theta_max);
    TH2F* hp_theta_energy_abs   = new TH2F("hp_theta_energy_abs",h_theta_energy_title,angle_bins,theta_min,theta_max,energy_bins,E_min,E_max);
    TH2F* hp_phi_energy_abs     = new TH2F("hp_phi_energy_abs",h_phi_energy_title,angle_bins,phi_min,phi_max,energy_bins,E_min,E_max);
    TH2F* hp_deltaenergy_energy = new TH2F("hp_deltaenergy_energy",h_deltaenergy_energy_title,energy_bins,E_min,E_max,res_bins_small,res_min,res_max);
    TH2F* hp_deltaenergy_phi    = new TH2F("hp_deltaenergy_phi",h_deltaenergy_phi_title,angle_bins,phi_min,phi_max,res_bins_small,res_min,res_max);
    TH2F* hp_deltaenergy_theta  = new TH2F("hp_deltaenergy_theta",h_deltaenergy_theta_title,angle_bins,theta_min,theta_max,res_bins_small,res_min,res_max);
    TH1F* hp_delta_energy       = new TH1F("hp_delta_energy",h_delta_energy_title,res_bins,res_min,res_max);

    // Struct for 2D histogram data computation.
    struct AverageCounter
    {
        double value = 0; // Here sum will be computed.
        int numbers  = 0; // How many times was a number added.

        double Average() { return (numbers == 0) ? 0 : value/numbers; }
    };
    

    // Arrays for 2D histograms.
    AverageCounter e_theta_phi[angle_bins][angle_bins];
    AverageCounter e_theta_energy[angle_bins][energy_bins];
    AverageCounter e_phi_energy[angle_bins][energy_bins];
    AverageCounter e_theta_phi_abs[angle_bins][angle_bins];
    AverageCounter e_theta_energy_abs[angle_bins][energy_bins];
    AverageCounter e_phi_energy_abs[angle_bins][energy_bins];

    AverageCounter p_theta_phi[angle_bins][angle_bins];
    AverageCounter p_theta_energy[angle_bins][energy_bins];
    AverageCounter p_phi_energy[angle_bins][energy_bins];
    AverageCounter p_theta_phi_abs[angle_bins][angle_bins];
    AverageCounter p_theta_energy_abs[angle_bins][energy_bins];
    AverageCounter p_phi_energy_abs[angle_bins][energy_bins];

    // Initialize arrays to zero.
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < angle_bins; j++)
    {
        e_theta_phi[i][j] = {0,0};
        p_theta_phi[i][j] = {0,0};
        e_theta_phi_abs[i][j] = {0,0};
        p_theta_phi_abs[i][j] = {0,0};
    }
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < energy_bins; j++)
    {
        e_theta_energy[i][j] = {0,0};
        e_phi_energy[i][j]   = {0,0};
        p_theta_energy[i][j] = {0,0};
        p_phi_energy[i][j]   = {0,0};

        e_theta_energy_abs[i][j] = {0,0};
        e_phi_energy_abs[i][j]   = {0,0};
        p_theta_energy_abs[i][j] = {0,0};
        p_phi_energy_abs[i][j]   = {0,0};
    }

    for (int i = 0; i < tracks_info->GetEntries(); i++)
    {
        tracks_info->GetEntry(i);

        double rk_resolution = curr_info->GetRKRelError();

        int phi_bin    = floor(angle_bins * (curr_info->phi - phi_min) / (phi_max - phi_min));
        int theta_bin  = floor(angle_bins * (curr_info->theta - theta_min) / (theta_max - theta_min));
        int energy_bin = floor(energy_bins * (curr_info->kin_energy - E_min) / (E_max - E_min));

        if (energy_bin == energy_bins) energy_bin--;

        if (curr_info->electron)
        {
            he_all->Fill(curr_info->phi,curr_info->theta,curr_info->kin_energy,rk_resolution);
            he_deltaenergy_energy->Fill(curr_info->kin_energy,rk_resolution);
            he_deltaenergy_phi->Fill(curr_info->phi,rk_resolution);
            he_deltaenergy_theta->Fill(curr_info->theta,rk_resolution);
            he_delta_energy->Fill(rk_resolution);

            e_theta_phi[phi_bin][theta_bin].value       += rk_resolution;
            e_theta_energy[theta_bin][energy_bin].value += rk_resolution;
            e_phi_energy[phi_bin][energy_bin].value     += rk_resolution;
            e_theta_phi_abs[phi_bin][theta_bin].value       += abs(rk_resolution);
            e_theta_energy_abs[theta_bin][energy_bin].value += abs(rk_resolution);
            e_phi_energy_abs[phi_bin][energy_bin].value     += abs(rk_resolution);

            e_theta_phi[phi_bin][theta_bin].numbers++;
            e_theta_energy[theta_bin][energy_bin].numbers++;
            e_phi_energy[phi_bin][energy_bin].numbers++;
            e_theta_phi_abs[phi_bin][theta_bin].numbers++;
            e_theta_energy_abs[theta_bin][energy_bin].numbers++;
            e_phi_energy_abs[phi_bin][energy_bin].numbers++;
        }

        else
        {
            hp_all->Fill(curr_info->phi,curr_info->theta,curr_info->kin_energy,rk_resolution);
            hp_deltaenergy_energy->Fill(curr_info->kin_energy,rk_resolution);
            hp_deltaenergy_phi->Fill(curr_info->phi,rk_resolution);
            hp_deltaenergy_theta->Fill(curr_info->theta,rk_resolution);
            hp_delta_energy->Fill(rk_resolution);

            p_theta_phi[phi_bin][theta_bin].value       += rk_resolution;
            p_theta_energy[theta_bin][energy_bin].value += rk_resolution;
            p_phi_energy[phi_bin][energy_bin].value     += rk_resolution;
            p_theta_phi_abs[phi_bin][theta_bin].value       += abs(rk_resolution);
            p_theta_energy_abs[theta_bin][energy_bin].value += abs(rk_resolution);
            p_phi_energy_abs[phi_bin][energy_bin].value     += abs(rk_resolution);

            p_theta_phi[phi_bin][theta_bin].numbers++;
            p_theta_energy[theta_bin][energy_bin].numbers++;
            p_phi_energy[phi_bin][energy_bin].numbers++;
            p_theta_phi_abs[phi_bin][theta_bin].numbers++;
            p_theta_energy_abs[theta_bin][energy_bin].numbers++;
            p_phi_energy_abs[phi_bin][energy_bin].numbers++;
        }
    }

    // Fill 2D histograms from arrays.
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < angle_bins; j++)
    {
        double phi = phi_min + (phi_max - phi_min) * (i + 0.5) / angle_bins;
        double theta = theta_min + (theta_max - theta_min) * (j + 0.5) / angle_bins;

        he_theta_phi->Fill(phi,theta,e_theta_phi[i][j].Average());
        he_theta_phi_abs->Fill(phi,theta,e_theta_phi_abs[i][j].Average());
        hp_theta_phi->Fill(phi,theta,p_theta_phi[i][j].Average());
        hp_theta_phi_abs->Fill(phi,theta,p_theta_phi_abs[i][j].Average());
    }
    for (int i = 0; i < angle_bins; i++) for (int j = 0; j < energy_bins; j++)
    {
        double phi   = phi_min + (phi_max - phi_min) * (i + 0.5) / angle_bins;
        double theta = theta_min + (theta_max - theta_min) * (i + 0.5) / angle_bins;
        double e_kin = E_min + (E_max - E_min) * j / energy_bins;

        he_theta_energy->Fill(theta,e_kin,e_theta_energy[i][j].Average());
        he_phi_energy->Fill(phi,e_kin,e_phi_energy[i][j].Average());
        hp_theta_energy->Fill(theta,e_kin,p_theta_energy[i][j].Average());
        hp_phi_energy->Fill(phi,e_kin,p_phi_energy[i][j].Average());
        he_theta_energy_abs->Fill(theta,e_kin,e_theta_energy_abs[i][j].Average());
        he_phi_energy_abs->Fill(phi,e_kin,e_phi_energy_abs[i][j].Average());
        hp_theta_energy_abs->Fill(theta,e_kin,p_theta_energy_abs[i][j].Average());
        hp_phi_energy_abs->Fill(phi,e_kin,p_phi_energy_abs[i][j].Average());
    }

    // Set the contour levels symmetrically around zero
    int ncont = 201;  // Number of contour levels (adjust as needed)
    Double_t contours[ncont + 1];
    for (int i = 0; i <= ncont; ++i) contours[i] = -10 + i * (20.0 / ncont);
    
    TCanvas* c_e_all = new TCanvas("c_e_all","");
    gStyle->SetPalette(kLightTemperature);
    he_all->SetStats(0);
    he_all->Draw("box2 z");
    he_all->SetContour(ncont,contours);
    c_e_all->Write();

    TCanvas* c_p_all = new TCanvas("c_p_all","");
    gStyle->SetPalette(kLightTemperature);
    hp_all->SetStats(0);
    hp_all->Draw("box2 z");
    hp_all->SetContour(ncont,contours);
    c_p_all->Write();

    TCanvas* c_e_theta_phi = new TCanvas("c_e_theta_phi","");
    gStyle->SetPalette(kLightTemperature);
    he_theta_phi->SetStats(0);
    he_theta_phi->Draw("colz");
    he_theta_phi->SetContour(ncont,contours);
    c_e_theta_phi->Write();

    TCanvas* c_p_theta_phi = new TCanvas("c_p_theta_phi","");
    gStyle->SetPalette(kLightTemperature);
    hp_theta_phi->SetStats(0);
    hp_theta_phi->Draw("colz");
    hp_theta_phi->SetContour(ncont,contours);
    c_p_theta_phi->Write();

    TCanvas* c_e_theta_energy = new TCanvas("c_e_theta_energy","");
    gStyle->SetPalette(kLightTemperature);
    he_theta_energy->SetStats(0);
    he_theta_energy->Draw("colz");
    he_theta_energy->SetContour(ncont,contours);
    c_e_theta_energy->Write();

    TCanvas* c_p_theta_energy = new TCanvas("c_p_theta_energy","");
    gStyle->SetPalette(kLightTemperature);
    hp_theta_energy->SetStats(0);
    hp_theta_energy->Draw("colz");
    hp_theta_energy->SetContour(ncont,contours);
    c_p_theta_energy->Write();

    TCanvas* c_e_phi_energy = new TCanvas("c_e_phi_energy","");
    gStyle->SetPalette(kLightTemperature);
    he_phi_energy->SetStats(0);
    he_phi_energy->Draw("colz");
    he_phi_energy->SetContour(ncont,contours);
    c_e_phi_energy->Write();

    TCanvas* c_p_phi_energy = new TCanvas("c_p_phi_energy","");
    gStyle->SetPalette(kLightTemperature);
    hp_phi_energy->SetStats(0);
    hp_phi_energy->Draw("colz");
    hp_phi_energy->SetContour(ncont,contours);
    c_p_phi_energy->Write();

    TCanvas* c_e_theta_phi_abs = new TCanvas("c_e_theta_phi_abs","");
    he_theta_phi_abs->SetStats(0);
    he_theta_phi_abs->Draw("colz");
    c_e_theta_phi_abs->Write();

    TCanvas* c_p_theta_phi_abs = new TCanvas("c_p_theta_phi_abs","");
    hp_theta_phi_abs->SetStats(0);
    hp_theta_phi_abs->Draw("colz");
    c_p_theta_phi_abs->Write();

    TCanvas* c_e_theta_energy_abs = new TCanvas("c_e_theta_energy_abs","");
    he_theta_energy_abs->SetStats(0);
    he_theta_energy_abs->Draw("colz");
    c_e_theta_energy_abs->Write();

    TCanvas* c_p_theta_energy_abs = new TCanvas("c_p_theta_energy_abs","");
    hp_theta_energy_abs->SetStats(0);
    hp_theta_energy_abs->Draw("colz");
    c_p_theta_energy_abs->Write();

    TCanvas* c_e_phi_energy_abs = new TCanvas("c_e_phi_energy_abs","");
    he_phi_energy_abs->SetStats(0);
    he_phi_energy_abs->Draw("colz");
    c_e_phi_energy_abs->Write();

    TCanvas* c_p_phi_energy_abs = new TCanvas("c_p_phi_energy_abs","");
    hp_phi_energy_abs->SetStats(0);
    hp_phi_energy_abs->Draw("colz");
    c_p_phi_energy_abs->Write();

    he_deltaenergy_energy->Write();
    he_deltaenergy_phi->Write();
    he_deltaenergy_theta->Write();

    hp_deltaenergy_energy->Write();
    hp_deltaenergy_phi->Write();
    hp_deltaenergy_theta->Write();

    TCanvas* c_e_delta_energy = new TCanvas("c_e_delta_energy","");
    he_delta_energy->SetStats(0);
    he_delta_energy->Draw();

    double fwhm = GetFWHM(he_delta_energy,true);
    double mean = he_delta_energy->GetMean();
    double stdev = he_delta_energy->GetStdDev();
    double skewness = he_delta_energy->GetSkewness();
    double kurtosis = he_delta_energy->GetKurtosis();

    // Add text labels with information
    TLatex* label = new TLatex();
    label->SetNDC();
    label->SetTextSize(0.035);

    label->DrawLatex(0.75, 0.85, Form("Mean: %.2f %%", mean));
    label->DrawLatex(0.75, 0.80, Form("FWHM: %.2f %%", fwhm));
    label->DrawLatex(0.75, 0.75, Form("RMS: %.2f %%", stdev));
    // label->DrawLatex(0.75, 0.75, Form("Skewness: %.2f", skewness));
    // label->DrawLatex(0.75, 0.70, Form("Kurtosis: %.2f", kurtosis));
    c_e_delta_energy->Write();
    
    TCanvas* c_p_delta_energy = new TCanvas("c_p_delta_energy","");
    hp_delta_energy->SetStats(0);
    hp_delta_energy->Draw();

    fwhm = GetFWHM(hp_delta_energy,true);
    mean = hp_delta_energy->GetMean();
    stdev = hp_delta_energy->GetStdDev();
    skewness = hp_delta_energy->GetSkewness();
    kurtosis = hp_delta_energy->GetKurtosis();

    // Add text labels with information
    TLatex* label2 = new TLatex();
    label2->SetNDC();
    label2->SetTextSize(0.035);

    label2->DrawLatex(0.75, 0.85, Form("Mean: %.2f %%", mean));
    label2->DrawLatex(0.75, 0.80, Form("FWHM: %.2f %%", fwhm));
    label2->DrawLatex(0.75, 0.75, Form("RMS: %.2f %%", stdev));
    // label2->DrawLatex(0.75, 0.75, Form("Skewness: %.2f", skewness));
    // label2->DrawLatex(0.75, 0.70, Form("Kurtosis: %.2f", kurtosis));
    c_p_delta_energy->Write();

    return 0;
}